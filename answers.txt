%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Name: David Sha
Login ID: dasha (unimelb), d4vidsha (gitlab)
Student ID: 1273615
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


================================================================================
1. Should the server accept calls from everyone, or just a subset of users?
--------------------------------------------------------------------------------
It depends on the use case. Server should accept calls from everyone on a
public service like Wikipedia. In the case of this project, server should
only accept calls from select users who know how to use the RPC framework.

================================================================================
2. Should authentication etc. be provided by the RPC framework, or by the 
functions that use the RPC framework?
--------------------------------------------------------------------------------
RPC framework should handle some authentication so that a standardised 
authentication process can be used across all functions that use the 
framework. If additional authentication is required, then the functions 
that use the RPC framework can implement their own authentication processes.

================================================================================
3. What transport layer protocol should be used? What are the trade-offs?
--------------------------------------------------------------------------------
TCP should be used over UDP. For the RPC framework, it is critical that 
packets are received in the correct order, and that no packets are lost. 
TCP provides this functionality. The trade-off for using TCP is that it 
is slower than UDP, as it requires a three-way handshake to establish a 
connection. This is a worthwhile trade-off.

================================================================================
4. In which function(s) should the socket(s) be created?
--------------------------------------------------------------------------------
Sockets should be created in the `rpc_init_server` and `rpc_init_client` 
functions. Sockets should be created before any RPC calls are made.

================================================================================
5. Should `rpc_client` and `rpc_server` be allocated dynamically or 
statically? What are the implications for the client and server code?
--------------------------------------------------------------------------------
`rpc_client` and `rpc_server` should be allocated dynamically. Without being
dynamic, the client and server code will need to manage the memory themselves,
which is poor encapsulation on the RPC framework's part.

================================================================================
6. What happens if one host uses big-endian byte order and the other uses 
little-endian? How does that relate to "network byte order"?
--------------------------------------------------------------------------------
The data will be interpreted incorrectly. Network byte order is big-endian, so 
data should be converted to big-endian before being sent over the network.
--------------------------------------------------------------------------------


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Protocol: 
Design and document a simple application layer protocol for this RPC system.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will use a single `rpc_message` struct to represent both requests 
and responses.

When sending an `rpc_message` across the network, we will use TCP due to
its reliability, albeit at the cost of speed (a feature of UDP). Reliability
ensures that IP layer packet loss and duplication is handled by the transport
layer, and that packets are received in the correct order.

Since IP packets have a maximum allowed size, our implementation will need
to handle multiple reads from a socket provided we know an expected size of 
the `rpc_message` struct.

Protocol steps:
1. Client sends `rpc_message` to server.
2. Server receives `rpc_message`.
3. Server sends a new `rpc_message` to client.
4. Client receives `rpc_message`.

The `rpc_message` struct will contain the following fields:
      `int request_id`: The ID of the request. Useful for matching 
                        requests to responses. The current implementation
                        does not use this but instead sets values to 0 by
                        default. Including this may be useful for future
                        extendibility.
             `enum op`: The operation can be either FIND, CALL, 
                        REPLY_SUCCESS or REPLY_FAILURE.
 `char *function_name`: The name of the function to be called 
                        or returned.
      `rpc_data *data`: The data to be passed to the function or returned 
                        by the function.

This `rpc_message` struct will be serialised into a byte array and sent 
over the network. When serialising, we will need to ensure that there 
are no padding or endianness issues.

It is worth noting that `op` is similar to status codes in HTTP. If the
operation is REPLY_FAILURE, it will signal that something went wrong when
processing a request which then can be handled accordingly by the client.

Elias Gamma Coding will be used to serialise `size_t` types, since we 
plan on extending this RPC framework in the future to support other
integer types.
--------------------------------------------------------------------------------
