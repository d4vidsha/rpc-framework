%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Name: David Sha
Login ID: dasha (unimelb), d4vidsha (gitlab)
Student ID: 1273615
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


================================================================================
1. Should the server accept calls from everyone, or just a subset of users?
--------------------------------------------------------------------------------
It depends on the use case. If the server is used for a public service, such 
as an ecommerce website, then it should accept calls from everyone. If the 
service is private, such as in the case of assessing this project, then it 
should only expect to receive calls from a limited number of clients.

================================================================================
2. Should authentication etc. be provided by the RPC framework, or by the 
functions that use the RPC framework?
--------------------------------------------------------------------------------
The RPC framework should handle the authentication so that a standardised 
authentication process can be used across all functions that use the 
framework. If additional authentication is required, then the functions 
that use the RPC framework can implement their own authentication processes.

================================================================================
3. What transport layer protocol should be used? What are the trade-offs?
--------------------------------------------------------------------------------
TCP should be used over UDP. For the RPC framework, it is critical that 
packets are received in the correct order, and that no packets are lost. 
TCP provides this functionality. The trade-off for using TCP is that it 
is slower than UDP, as it requires a three-way handshake to establish a 
connection, and it also requires the server to keep track of the state of 
each connection. This is a worthwhile trade-off however.

================================================================================
4. In which function(s) should the socket(s) be created?
--------------------------------------------------------------------------------
Sockets should be created in the `rpc_init_server` and `rpc_init_client` 
functions. Sockets should be created before any RPC calls are made.

================================================================================
5. Should `rpc_client` and `rpc_server` be allocated dynamically or 
statically? What are the implications for the client and server code?
--------------------------------------------------------------------------------
`rpc_client` and `rpc_server` should be allocated dynamically. If they 
were allocated statically, only one client and one server could be created, 
limiting the functionality of the RPC framework.

================================================================================
6. What happens if one host uses big-endian byte order and the other uses 
little-endian? How does that relate to "network byte order"?
--------------------------------------------------------------------------------
If one host uses big-endian and the other uses little-endian, then the data 
will be interpreted incorrectly. Network byte order is big-endian, so the 
data should be converted to big-endian before being sent over the network.
--------------------------------------------------------------------------------


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Protocol: 
Design and document a simple application layer protocol for this RPC system.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will use a single `rpc_message` struct to represent both requests 
and responses.

When sending an `rpc_message` across the network, we will use TCP due to
its reliability, albeit at the cost of speed (a feature of UDP). Reliability
ensures that IP layer packet loss and duplication is handled by the transport
layer, and that packets are received in the correct order.

Since IP packets have a maximum allowed size, our implementation will need
to handle multiple reads from a socket provided we know an expected size of 
the `rpc_message` struct.

Protocol steps:
1. Client sends `rpc_message` to server.
2. Server receives `rpc_message`.
3. Server sends a new `rpc_message` to client.
4. Client receives `rpc_message`.

The `rpc_message` struct will contain the following fields:
      `int request_id`: The ID of the request. Useful for matching 
                        requests to responses. The current implementation
                        does not use this but instead sets values to 0 by
                        default. Including this may be useful for future
                        extendibility.
             `enum op`: The operation can be either FIND, CALL, 
                        REPLY_SUCCESS or REPLY_FAILURE.
 `char *function_name`: The name of the function to be called 
                        or returned.
      `rpc_data *data`: The data to be passed to the function or returned 
                        by the function.

This `rpc_message` struct will be serialised into a byte array and sent 
over the network. When serialising, we will need to ensure that there 
are no padding or endianness issues.

It is worth noting that `op` is similar to status codes in HTTP. If the
operation is REPLY_FAILURE, it will signal that something went wrong when
processing a request which then can be handled accordingly by the client.

Elias Gamma Coding should be used to serialise `size_t` types. This is
because `size_t` varies in byte size across different machines, meaning
that serialising directly by `memcpy()` will not work. Elias Gamma Coding
is a universal way of serialising `size_t` and any other unsigned integer
types. Since we plan on extending this RPC framework in the future, we will
opt for Elias Gamma Coding as it is a more extendible solution.
--------------------------------------------------------------------------------
